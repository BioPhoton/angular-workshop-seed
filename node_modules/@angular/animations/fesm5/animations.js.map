{"version":3,"file":"animations.js","sources":["../../../../../../../../../../execroot/angular/packages/animations/src/animation_builder.ts","../../../../../../../../../../execroot/angular/packages/animations/src/animation_metadata.ts","../../../../../../../../../../execroot/angular/packages/animations/src/util.ts","../../../../../../../../../../execroot/angular/packages/animations/src/players/animation_player.ts","../../../../../../../../../../execroot/angular/packages/animations/src/players/animation_group_player.ts","../../../../../../../../../../execroot/angular/packages/animations/src/private_export.ts","../../../../../../../../../../execroot/angular/packages/animations/animations.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimationMetadata, AnimationOptions} from './animation_metadata';\nimport {AnimationPlayer} from './players/animation_player';\n\n/**\n * AnimationBuilder is an injectable service that is available when the {@link\n * BrowserAnimationsModule BrowserAnimationsModule} or {@link NoopAnimationsModule\n * NoopAnimationsModule} modules are used within an application.\n *\n * The purpose if this service is to produce an animation sequence programmatically within an\n * angular component or directive.\n *\n * Programmatic animations are first built and then a player is created when the build animation is\n * attached to an element.\n *\n * ```ts\n * // remember to include the BrowserAnimationsModule module for this to work...\n * import {AnimationBuilder} from '@angular/animations';\n *\n * class MyCmp {\n *   constructor(private _builder: AnimationBuilder) {}\n *\n *   makeAnimation(element: any) {\n *     // first build the animation\n *     const myAnimation = this._builder.build([\n *       style({ width: 0 }),\n *       animate(1000, style({ width: '100px' }))\n *     ]);\n *\n *     // then create a player from it\n *     const player = myAnimation.create(element);\n *\n *     player.play();\n *   }\n * }\n * ```\n *\n * When an animation is built an instance of {@link AnimationFactory AnimationFactory} will be\n * returned. Using that an {@link AnimationPlayer AnimationPlayer} can be created which can then be\n * used to start the animation.\n *\n * @experimental Animation support is experimental.\n */\nexport abstract class AnimationBuilder {\n  abstract build(animation: AnimationMetadata|AnimationMetadata[]): AnimationFactory;\n}\n\n/**\n * An instance of `AnimationFactory` is returned from {@link AnimationBuilder#build\n * AnimationBuilder.build}.\n *\n * @experimental Animation support is experimental.\n */\nexport abstract class AnimationFactory {\n  abstract create(element: any, options?: AnimationOptions): AnimationPlayer;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface ÉµStyleData { [key: string]: string|number; }\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are created internally\n * within the Angular animation DSL.\n *\n * @experimental Animation support is experimental.\n */\nexport declare type AnimateTimings = {\n  duration: number,\n  delay: number,\n  easing: string | null\n};\n\n/**\n * `AnimationOptions` represents options that can be passed into most animation DSL methods.\n * When options are provided, the delay value of an animation can be changed and animation input\n * parameters can be passed in to change styling and timing data when an animation is started.\n *\n * The following animation DSL functions are able to accept animation option data:\n *\n * - {@link transition transition()}\n * - {@link sequence sequence()}\n * - {@link group group()}\n * - {@link query query()}\n * - {@link animation animation()}\n * - {@link useAnimation useAnimation()}\n * - {@link animateChild animateChild()}\n *\n * Programmatic animations built using {@link AnimationBuilder the AnimationBuilder service} also\n * make use of AnimationOptions.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimationOptions {\n  delay?: number|string;\n  params?: {[name: string]: any};\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are created internally\n * within the Angular animation DSL when {@link animateChild animateChild()} is used.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimateChildOptions extends AnimationOptions { duration?: number|string; }\n\n/**\n * Metadata representing the entry of animations. Usages of this enum are created\n * each time an animation DSL function is used.\n *\n * @experimental Animation support is experimental.\n */\nexport const enum AnimationMetadataType {\n  State = 0,\n  Transition = 1,\n  Sequence = 2,\n  Group = 3,\n  Animate = 4,\n  Keyframes = 5,\n  Style = 6,\n  Trigger = 7,\n  Reference = 8,\n  AnimateChild = 9,\n  AnimateRef = 10,\n  Query = 11,\n  Stagger = 12\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport const AUTO_STYLE = '*';\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationMetadata { type: AnimationMetadataType; }\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link trigger trigger animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationTriggerMetadata extends AnimationMetadata {\n  name: string;\n  definitions: AnimationMetadata[];\n  options: {params?: {[name: string]: any}}|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link state state animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationStateMetadata extends AnimationMetadata {\n  name: string;\n  styles: AnimationStyleMetadata;\n  options?: {params: {[name: string]: any}};\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link transition transition animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationTransitionMetadata extends AnimationMetadata {\n  expr: string|\n      ((fromState: string, toState: string, element?: any,\n        params?: {[key: string]: any}) => boolean);\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationReferenceMetadata extends AnimationMetadata {\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationQueryMetadata extends AnimationMetadata {\n  selector: string;\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationQueryOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link keyframes keyframes animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {\n  steps: AnimationStyleMetadata[];\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link style style animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationStyleMetadata extends AnimationMetadata {\n  styles: '*'|{[key: string]: string | number}|Array<{[key: string]: string | number}|'*'>;\n  offset: number|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link animate animate animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateMetadata extends AnimationMetadata {\n  timings: string|number|AnimateTimings;\n  styles: AnimationStyleMetadata|AnimationKeyframesSequenceMetadata|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link animateChild animateChild animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateChildMetadata extends AnimationMetadata {\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link useAnimation useAnimation animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateRefMetadata extends AnimationMetadata {\n  animation: AnimationReferenceMetadata;\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link sequence sequence animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationSequenceMetadata extends AnimationMetadata {\n  steps: AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link group group animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationGroupMetadata extends AnimationMetadata {\n  steps: AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link query query animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimationQueryOptions extends AnimationOptions {\n  optional?: boolean;\n  /**\n   * Used to limit the total amount of results from the start of the query list.\n   *\n   * If a negative value is provided then the queried results will be limited from the\n   * end of the query list towards the beginning (e.g. if `limit: -3` is used then the\n   * final 3 (or less) queried results will be used for the animation).\n   */\n  limit?: number;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link stagger stagger animation function} is called.\n *\n* @experimental Animation support is experimental.\n*/\nexport interface AnimationStaggerMetadata extends AnimationMetadata {\n  timings: string|number;\n  animation: AnimationMetadata|AnimationMetadata[];\n}\n\n/**\n * `trigger` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the\n * {@link Component#animations component animations metadata page} to gain a better\n * understanding of how animations in Angular are used.\n *\n * `trigger` Creates an animation trigger which will a list of {@link state state} and\n * {@link transition transition} entries that will be evaluated when the expression\n * bound to the trigger changes.\n *\n * Triggers are registered within the component annotation data under the\n * {@link Component#animations animations section}. An animation trigger can be placed on an element\n * within a template by referencing the name of the trigger followed by the expression value that\n the\n * trigger is bound to (in the form of `[@triggerName]=\"expression\"`.\n *\n * Animation trigger bindings strigify values and then match the previous and current values against\n * any linked transitions. If a boolean value is provided into the trigger binding then it will both\n * be represented as `1` or `true` and `0` or `false` for a true and false boolean values\n * respectively.\n *\n * ### Usage\n *\n * `trigger` will create an animation trigger reference based on the provided `name` value. The\n * provided `animation` value is expected to be an array consisting of {@link state state} and\n * {@link transition transition} declarations.\n *\n * ```typescript\n * @Component({\n *   selector: 'my-component',\n *   templateUrl: 'my-component-tpl.html',\n *   animations: [\n *     trigger(\"myAnimationTrigger\", [\n *       state(...),\n *       state(...),\n *       transition(...),\n *       transition(...)\n *     ])\n *   ]\n * })\n * class MyComponent {\n *   myStatusExp = \"something\";\n * }\n * ```\n *\n * The template associated with this component will make use of the `myAnimationTrigger` animation\n trigger by binding to an element within its template code.\n *\n * ```html\n * <!-- somewhere inside of my-component-tpl.html -->\n * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n * ```\n *\n * ### Using an inline function\n * The `transition` animation method also supports reading an inline function which can decide\n * if its associated animation should be run.\n *\n * ```\n * // this method will be run each time the `myAnimationTrigger`\n * // trigger value changes...\n * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:\n string]: any}): boolean {\n *   // notice that `element` and `params` are also available here\n *   return toState == 'yes-please-animate';\n * }\n *\n * @Component({\n *   selector: 'my-component',\n *   templateUrl: 'my-component-tpl.html',\n *   animations: [\n *     trigger('myAnimationTrigger', [\n *       transition(myInlineMatcherFn, [\n *         // the animation sequence code\n *       ]),\n *     ])\n *   ]\n * })\n * class MyComponent {\n *   myStatusExp = \"yes-please-animate\";\n * }\n * ```\n *\n * The inline method will be run each time the trigger\n * value changes\n *\n * ## Disable Animations\n * A special animation control binding called `@.disabled` can be placed on an element which will\n then disable animations for any inner animation triggers situated within the element as well as\n any animations on the element itself.\n *\n * When true, the `@.disabled` binding will prevent all animations from rendering. The example\n below shows how to use this feature:\n *\n * ```ts\n * @Component({\n *   selector: 'my-component',\n *   template: `\n *     <div [@.disabled]=\"isDisabled\">\n *       <div [@childAnimation]=\"exp\"></div>\n *     </div>\n *   `,\n *   animations: [\n *     trigger(\"childAnimation\", [\n *       // ...\n *     ])\n *   ]\n * })\n * class MyComponent {\n *   isDisabled = true;\n *   exp = '...';\n * }\n * ```\n *\n * The `@childAnimation` trigger will not animate because `@.disabled` prevents it from happening\n (when true).\n *\n * Note that `@.disabled` will only disable all animations (this means any animations running on\n * the same element will also be disabled).\n *\n * ### Disabling Animations Application-wide\n * When an area of the template is set to have animations disabled, **all** inner components will\n also have their animations disabled as well. This means that all animations for an angular\n application can be disabled by placing a host binding set on `@.disabled` on the topmost Angular\n component.\n *\n * ```ts\n * import {Component, HostBinding} from '@angular/core';\n *\n * @Component({\n *   selector: 'app-component',\n *   templateUrl: 'app.component.html',\n * })\n * class AppComponent {\n *   @HostBinding('@.disabled')\n *   public animationsDisabled = true;\n * }\n * ```\n *\n * ### What about animations that us `query()` and `animateChild()`?\n * Despite inner animations being disabled, a parent animation can {@link query query} for inner\n elements located in disabled areas of the template and still animate them as it sees fit. This is\n also the case for when a sub animation is queried by a parent and then later animated using {@link\n animateChild animateChild}.\n\n * ### Detecting when an animation is disabled\n * If a region of the DOM (or the entire application) has its animations disabled, then animation\n * trigger callbacks will still fire just as normal (only for zero seconds).\n *\n * When a trigger callback fires it will provide an instance of an {@link AnimationEvent}. If\n animations\n * are disabled then the `.disabled` flag on the event will be true.\n *\n * @experimental Animation support is experimental.\n */\nexport function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata {\n  return {type: AnimationMetadataType.Trigger, name, definitions, options: {}};\n}\n\n/**\n * `animate` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `animate` specifies an animation step that will apply the provided `styles` data for a given\n * amount of time based on the provided `timing` expression value. Calls to `animate` are expected\n * to be used within {@link sequence an animation sequence}, {@link group group}, or {@link\n * transition transition}.\n *\n * ### Usage\n *\n * The `animate` function accepts two input parameters: `timing` and `styles`:\n *\n * - `timing` is a string based value that can be a combination of a duration with optional delay\n * and easing values. The format for the expression breaks down to `duration delay easing`\n * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,\n * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the\n * `duration` value in millisecond form.\n * - `styles` is the style input data which can either be a call to {@link style style} or {@link\n * keyframes keyframes}. If left empty then the styles from the destination state will be collected\n * and used (this is useful when describing an animation step that will complete an animation by\n * {@link transition#the-final-animate-call animating to the final state}).\n *\n * ```typescript\n * // various functions for specifying timing data\n * animate(500, style(...))\n * animate(\"1s\", style(...))\n * animate(\"100ms 0.5s\", style(...))\n * animate(\"5s ease\", style(...))\n * animate(\"5s 10ms cubic-bezier(.17,.67,.88,.1)\", style(...))\n *\n * // either style() of keyframes() can be used\n * animate(500, style({ background: \"red\" }))\n * animate(500, keyframes([\n *   style({ background: \"blue\" })),\n *   style({ background: \"red\" }))\n * ])\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function animate(\n    timings: string | number, styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata |\n        null = null): AnimationAnimateMetadata {\n  return {type: AnimationMetadataType.Animate, styles, timings};\n}\n\n/**\n * `group` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are\n * useful when a series of styles must be animated/closed off at different starting/ending times.\n *\n * The `group` function can either be used within a {@link sequence sequence} or a {@link transition\n * transition} and it will only continue to the next instruction once all of the inner animation\n * steps have completed.\n *\n * ### Usage\n *\n * The `steps` data that is passed into the `group` animation function can either consist of {@link\n * style style} or {@link animate animate} function calls. Each call to `style()` or `animate()`\n * within a group will be executed instantly (use {@link keyframes keyframes} or a {@link\n * animate#usage animate() with a delay value} to offset styles to be applied at a later time).\n *\n * ```typescript\n * group([\n *   animate(\"1s\", { background: \"black\" }))\n *   animate(\"2s\", { color: \"white\" }))\n * ])\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function group(\n    steps: AnimationMetadata[], options: AnimationOptions | null = null): AnimationGroupMetadata {\n  return {type: AnimationMetadataType.Group, steps, options};\n}\n\n/**\n * `sequence` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by\n * default when an array is passed as animation data into {@link transition transition}.)\n *\n * The `sequence` function can either be used within a {@link group group} or a {@link transition\n * transition} and it will only continue to the next instruction once each of the inner animation\n * steps have completed.\n *\n * To perform animation styling in parallel with other animation steps then have a look at the\n * {@link group group} animation function.\n *\n * ### Usage\n *\n * The `steps` data that is passed into the `sequence` animation function can either consist of\n * {@link style style} or {@link animate animate} function calls. A call to `style()` will apply the\n * provided styling data immediately while a call to `animate()` will apply its styling data over a\n * given time depending on its timing data.\n *\n * ```typescript\n * sequence([\n *   style({ opacity: 0 })),\n *   animate(\"1s\", { opacity: 1 }))\n * ])\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function sequence(steps: AnimationMetadata[], options: AnimationOptions | null = null):\n    AnimationSequenceMetadata {\n  return {type: AnimationMetadataType.Sequence, steps, options};\n}\n\n/**\n * `style` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `style` declares a key/value object containing CSS properties/styles that can then be used for\n * {@link state animation states}, within an {@link sequence animation sequence}, or as styling data\n * for both {@link animate animate} and {@link keyframes keyframes}.\n *\n * ### Usage\n *\n * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs\n * to be defined.\n *\n * ```typescript\n * // string values are used for css properties\n * style({ background: \"red\", color: \"blue\" })\n *\n * // numerical (pixel) values are also supported\n * style({ width: 100, height: 0 })\n * ```\n *\n * #### Auto-styles (using `*`)\n *\n * When an asterix (`*`) character is used as a value then it will be detected from the element\n * being animated and applied as animation data when the animation starts.\n *\n * This feature proves useful for a state depending on layout and/or environment factors; in such\n * cases the styles are calculated just before the animation starts.\n *\n * ```typescript\n * // the steps below will animate from 0 to the\n * // actual height of the element\n * style({ height: 0 }),\n * animate(\"1s\", style({ height: \"*\" }))\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function style(\n    tokens: '*' | {[key: string]: string | number} |\n    Array<'*'|{[key: string]: string | number}>): AnimationStyleMetadata {\n  return {type: AnimationMetadataType.Style, styles: tokens, offset: null};\n}\n\n/**\n * `state` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `state` declares an animation state within the given trigger. When a state is active within a\n * component then its associated styles will persist on the element that the trigger is attached to\n * (even when the animation ends).\n *\n * To animate between states, have a look at the animation {@link transition transition} DSL\n * function. To register states to an animation trigger please have a look at the {@link trigger\n * trigger} function.\n *\n * #### The `void` state\n *\n * The `void` state value is a reserved word that angular uses to determine when the element is not\n * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the\n * associated element is void).\n *\n * #### The `*` (default) state\n *\n * The `*` state (when styled) is a fallback state that will be used if the state that is being\n * animated is not declared within the trigger.\n *\n * ### Usage\n *\n * `state` will declare an animation state with its associated styles\n * within the given trigger.\n *\n * - `stateNameExpr` can be one or more state names separated by commas.\n * - `styles` refers to the {@link style styling data} that will be persisted on the element once\n * the state has been reached.\n *\n * ```typescript\n * // \"void\" is a reserved name for a state and is used to represent\n * // the state in which an element is detached from from the application.\n * state(\"void\", style({ height: 0 }))\n *\n * // user-defined states\n * state(\"closed\", style({ height: 0 }))\n * state(\"open, visible\", style({ height: \"*\" }))\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function state(\n    name: string, styles: AnimationStyleMetadata,\n    options?: {params: {[name: string]: any}}): AnimationStateMetadata {\n  return {type: AnimationMetadataType.State, name, styles, options};\n}\n\n/**\n * `keyframes` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `keyframes` specifies a collection of {@link style style} entries each optionally characterized\n * by an `offset` value.\n *\n * ### Usage\n *\n * The `keyframes` animation function is designed to be used alongside the {@link animate animate}\n * animation function. Instead of applying animations from where they are currently to their\n * destination, keyframes can describe how each style entry is applied and at what point within the\n * animation arc (much like CSS Keyframe Animations do).\n *\n * For each `style()` entry an `offset` value can be set. Doing so allows to specify at what\n * percentage of the animate time the styles will be applied.\n *\n * ```typescript\n * // the provided offset values describe when each backgroundColor value is applied.\n * animate(\"5s\", keyframes([\n *   style({ backgroundColor: \"red\", offset: 0 }),\n *   style({ backgroundColor: \"blue\", offset: 0.2 }),\n *   style({ backgroundColor: \"orange\", offset: 0.3 }),\n *   style({ backgroundColor: \"black\", offset: 1 })\n * ]))\n * ```\n *\n * Alternatively, if there are no `offset` values used within the style entries then the offsets\n * will be calculated automatically.\n *\n * ```typescript\n * animate(\"5s\", keyframes([\n *   style({ backgroundColor: \"red\" }) // offset = 0\n *   style({ backgroundColor: \"blue\" }) // offset = 0.33\n *   style({ backgroundColor: \"orange\" }) // offset = 0.66\n *   style({ backgroundColor: \"black\" }) // offset = 1\n * ]))\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata {\n  return {type: AnimationMetadataType.Keyframes, steps};\n}\n\n/**\n * `transition` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n *\n * `transition` declares the {@link sequence sequence of animation steps} that will be run when the\n * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>\n * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting\n * and/or ending state).\n *\n * A function can also be provided as the `stateChangeExpr` argument for a transition and this\n * function will be executed each time a state change occurs. If the value returned within the\n * function is true then the associated animation will be run.\n *\n * Animation transitions are placed within an {@link trigger animation trigger}. For an transition\n * to animate to a state value and persist its styles then one or more {@link state animation\n * states} is expected to be defined.\n *\n * ### Usage\n *\n * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on\n * what the previous state is and what the current state has become. In other words, if a transition\n * is defined that matches the old/current state criteria then the associated animation will be\n * triggered.\n *\n * ```typescript\n * // all transition/state changes are defined within an animation trigger\n * trigger(\"myAnimationTrigger\", [\n *   // if a state is defined then its styles will be persisted when the\n *   // animation has fully completed itself\n *   state(\"on\", style({ background: \"green\" })),\n *   state(\"off\", style({ background: \"grey\" })),\n *\n *   // a transition animation that will be kicked off when the state value\n *   // bound to \"myAnimationTrigger\" changes from \"on\" to \"off\"\n *   transition(\"on => off\", animate(500)),\n *\n *   // it is also possible to do run the same animation for both directions\n *   transition(\"on <=> off\", animate(500)),\n *\n *   // or to define multiple states pairs separated by commas\n *   transition(\"on => off, off => void\", animate(500)),\n *\n *   // this is a catch-all state change for when an element is inserted into\n *   // the page and the destination state is unknown\n *   transition(\"void => *\", [\n *     style({ opacity: 0 }),\n *     animate(500)\n *   ]),\n *\n *   // this will capture a state change between any states\n *   transition(\"* => *\", animate(\"1s 0s\")),\n *\n *   // you can also go full out and include a function\n *   transition((fromState, toState) => {\n *     // when `true` then it will allow the animation below to be invoked\n *     return fromState == \"off\" && toState == \"on\";\n *   }, animate(\"1s 0s\"))\n * ])\n * ```\n *\n * The template associated with this component will make use of the `myAnimationTrigger` animation\n * trigger by binding to an element within its template code.\n *\n * ```html\n * <!-- somewhere inside of my-component-tpl.html -->\n * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n * ```\n *\n * #### The final `animate` call\n *\n * If the final step within the transition steps is a call to `animate()` that **only** uses a\n * timing value with **no style data** then it will be automatically used as the final animation arc\n * for the element to animate itself to the final state. This involves an automatic mix of\n * adding/removing CSS styles so that the element will be in the exact state it should be for the\n * applied state to be presented correctly.\n *\n * ```\n * // start off by hiding the element, but make sure that it animates properly to whatever state\n * // is currently active for \"myAnimationTrigger\"\n * transition(\"void => *\", [\n *   style({ opacity: 0 }),\n *   animate(500)\n * ])\n * ```\n *\n * ### Using :enter and :leave\n *\n * Given that enter (insertion) and leave (removal) animations are so common, the `transition`\n * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*\n * => void` state changes.\n *\n * ```\n * transition(\":enter\", [\n *   style({ opacity: 0 }),\n *   animate(500, style({ opacity: 1 }))\n * ]),\n * transition(\":leave\", [\n *   animate(500, style({ opacity: 0 }))\n * ])\n * ```\n *\n * ### Boolean values\n * if a trigger binding value is a boolean value then it can be matched using a transition\n * expression that compares `true` and `false` or `1` and `0`.\n *\n * ```\n * // in the template\n * <div [@openClose]=\"open ? true : false\">...</div>\n *\n * // in the component metadata\n * trigger('openClose', [\n *   state('true', style({ height: '*' })),\n *   state('false', style({ height: '0px' })),\n *   transition('false <=> true', animate(500))\n * ])\n * ```\n *\n * ### Using :increment and :decrement\n * In addition to the :enter and :leave transition aliases, the :increment and :decrement aliases\n * can be used to kick off a transition when a numeric value has increased or decreased in value.\n *\n * ```\n * import {group, animate, query, transition, style, trigger} from '@angular/animations';\n * import {Component} from '@angular/core';\n *\n * @Component({\n *   selector: 'banner-carousel-component',\n *   styles: [`\n *     .banner-container {\n *        position:relative;\n *        height:500px;\n *        overflow:hidden;\n *      }\n *     .banner-container > .banner {\n *        position:absolute;\n *        left:0;\n *        top:0;\n *        font-size:200px;\n *        line-height:500px;\n *        font-weight:bold;\n *        text-align:center;\n *        width:100%;\n *      }\n *   `],\n *   template: `\n *     <button (click)=\"previous()\">Previous</button>\n *     <button (click)=\"next()\">Next</button>\n *     <hr>\n *     <div [@bannerAnimation]=\"selectedIndex\" class=\"banner-container\">\n *       <div class=\"banner\" *ngFor=\"let banner of banners\"> {{ banner }} </div>\n *     </div>\n *   `,\n *   animations: [\n *     trigger('bannerAnimation', [\n *       transition(\":increment\", group([\n *         query(':enter', [\n *           style({ left: '100%' }),\n *           animate('0.5s ease-out', style('*'))\n *         ]),\n *         query(':leave', [\n *           animate('0.5s ease-out', style({ left: '-100%' }))\n *         ])\n *       ])),\n *       transition(\":decrement\", group([\n *         query(':enter', [\n *           style({ left: '-100%' }),\n *           animate('0.5s ease-out', style('*'))\n *         ]),\n *         query(':leave', [\n *           animate('0.5s ease-out', style({ left: '100%' }))\n *         ])\n *       ]))\n *     ])\n *   ]\n * })\n * class BannerCarouselComponent {\n *   allBanners: string[] = ['1', '2', '3', '4'];\n *   selectedIndex: number = 0;\n *\n *   get banners() {\n *      return [this.allBanners[this.selectedIndex]];\n *   }\n *\n *   previous() {\n *     this.selectedIndex = Math.max(this.selectedIndex - 1, 0);\n *   }\n *\n *   next() {\n *     this.selectedIndex = Math.min(this.selectedIndex + 1, this.allBanners.length - 1);\n *   }\n * }\n * ```\n *\n * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n *\n * @experimental Animation support is experimental.\n */\nexport function transition(\n    stateChangeExpr: string | ((fromState: string, toState: string, element?: any,\n                                params?: {[key: string]: any}) => boolean),\n    steps: AnimationMetadata | AnimationMetadata[],\n    options: AnimationOptions | null = null): AnimationTransitionMetadata {\n  return {type: AnimationMetadataType.Transition, expr: stateChangeExpr, animation: steps, options};\n}\n\n/**\n * `animation` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language.\n *\n * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later\n * invoked in another animation or sequence. Reusable animations are designed to make use of\n * animation parameters and the produced animation can be used via the `useAnimation` method.\n *\n * ```\n * var fadeAnimation = animation([\n *   style({ opacity: '{{ start }}' }),\n *   animate('{{ time }}',\n *     style({ opacity: '{{ end }}'}))\n * ], { params: { time: '1000ms', start: 0, end: 1 }});\n * ```\n *\n * If parameters are attached to an animation then they act as **default parameter values**. When an\n * animation is invoked via `useAnimation` then parameter values are allowed to be passed in\n * directly. If any of the passed in parameter values are missing then the default values will be\n * used.\n *\n * ```\n * useAnimation(fadeAnimation, {\n *   params: {\n *     time: '2s',\n *     start: 1,\n *     end: 0\n *   }\n * })\n * ```\n *\n * If one or more parameter values are missing before animated then an error will be thrown.\n *\n * @experimental Animation support is experimental.\n */\nexport function animation(\n    steps: AnimationMetadata | AnimationMetadata[],\n    options: AnimationOptions | null = null): AnimationReferenceMetadata {\n  return {type: AnimationMetadataType.Reference, animation: steps, options};\n}\n\n/**\n * `animateChild` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It works by allowing a queried element to execute its own\n * animation within the animation sequence.\n *\n * Each time an animation is triggered in angular, the parent animation\n * will always get priority and any child animations will be blocked. In order\n * for a child animation to run, the parent animation must query each of the elements\n * containing child animations and then allow the animations to run using `animateChild`.\n *\n * The example HTML code below shows both parent and child elements that have animation\n * triggers that will execute at the same time.\n *\n * ```html\n * <!-- parent-child.component.html -->\n * <button (click)=\"exp =! exp\">Toggle</button>\n * <hr>\n *\n * <div [@parentAnimation]=\"exp\">\n *   <header>Hello</header>\n *   <div [@childAnimation]=\"exp\">\n *       one\n *   </div>\n *   <div [@childAnimation]=\"exp\">\n *       two\n *   </div>\n *   <div [@childAnimation]=\"exp\">\n *       three\n *   </div>\n * </div>\n * ```\n *\n * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate\n * because it has priority. However, using `query` and `animateChild` each of the inner animations\n * can also fire:\n *\n * ```ts\n * // parent-child.component.ts\n * import {trigger, transition, animate, style, query, animateChild} from '@angular/animations';\n * @Component({\n *   selector: 'parent-child-component',\n *   animations: [\n *     trigger('parentAnimation', [\n *       transition('false => true', [\n *         query('header', [\n *           style({ opacity: 0 }),\n *           animate(500, style({ opacity: 1 }))\n *         ]),\n *         query('@childAnimation', [\n *           animateChild()\n *         ])\n *       ])\n *     ]),\n *     trigger('childAnimation', [\n *       transition('false => true', [\n *         style({ opacity: 0 }),\n *         animate(500, style({ opacity: 1 }))\n *       ])\n *     ])\n *   ]\n * })\n * class ParentChildCmp {\n *   exp: boolean = false;\n * }\n * ```\n *\n * In the animation code above, when the `parentAnimation` transition kicks off it first queries to\n * find the header element and fades it in. It then finds each of the sub elements that contain the\n * `@childAnimation` trigger and then allows for their animations to fire.\n *\n * This example can be further extended by using stagger:\n *\n * ```ts\n * query('@childAnimation', stagger(100, [\n *   animateChild()\n * ]))\n * ```\n *\n * Now each of the sub animations start off with respect to the `100ms` staggering step.\n *\n * ## The first frame of child animations\n * When sub animations are executed using `animateChild` the animation engine will always apply the\n * first frame of every sub animation immediately at the start of the animation sequence. This way\n * the parent animation does not need to set any initial styling data on the sub elements before the\n * sub animations kick off.\n *\n * In the example above the first frame of the `childAnimation`'s `false => true` transition\n * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`\n * animation transition sequence starts. Only then when the `@childAnimation` is queried and called\n * with `animateChild` will it then animate to its destination of `opacity: 1`.\n *\n * Note that this feature designed to be used alongside {@link query query()} and it will only work\n * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes\n * and transitions are not handled by this API).\n *\n * @experimental Animation support is experimental.\n */\nexport function animateChild(options: AnimateChildOptions | null = null):\n    AnimationAnimateChildMetadata {\n  return {type: AnimationMetadataType.AnimateChild, options};\n}\n\n/**\n * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It is used to kick off a reusable animation that is created using {@link\n * animation animation()}.\n *\n * @experimental Animation support is experimental.\n */\nexport function useAnimation(\n    animation: AnimationReferenceMetadata,\n    options: AnimationOptions | null = null): AnimationAnimateRefMetadata {\n  return {type: AnimationMetadataType.AnimateRef, animation, options};\n}\n\n/**\n * `query` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language.\n *\n * query() is used to find one or more inner elements within the current element that is\n * being animated within the sequence. The provided animation steps are applied\n * to the queried element (by default, an array is provided, then this will be\n * treated as an animation sequence).\n *\n * ### Usage\n *\n * query() is designed to collect multiple elements and works internally by using\n * `element.querySelectorAll`. An additional options object can be provided which\n * can be used to limit the total amount of items to be collected.\n *\n * ```js\n * query('div', [\n *   animate(...),\n *   animate(...)\n * ], { limit: 1 })\n * ```\n *\n * query(), by default, will throw an error when zero items are found. If a query\n * has the `optional` flag set to true then this error will be ignored.\n *\n * ```js\n * query('.some-element-that-may-not-be-there', [\n *   animate(...),\n *   animate(...)\n * ], { optional: true })\n * ```\n *\n * ### Special Selector Values\n *\n * The selector value within a query can collect elements that contain angular-specific\n * characteristics\n * using special pseudo-selectors tokens.\n *\n * These include:\n *\n *  - Querying for newly inserted/removed elements using `query(\":enter\")`/`query(\":leave\")`\n *  - Querying all currently animating elements using `query(\":animating\")`\n *  - Querying elements that contain an animation trigger using `query(\"@triggerName\")`\n *  - Querying all elements that contain an animation triggers using `query(\"@*\")`\n *  - Including the current element into the animation sequence using `query(\":self\")`\n *\n *\n *  Each of these pseudo-selector tokens can be merged together into a combined query selector\n * string:\n *\n *  ```\n *  query(':self, .record:enter, .record:leave, @subTrigger', [...])\n *  ```\n *\n * ### Demo\n *\n * ```\n * @Component({\n *   selector: 'inner',\n *   template: `\n *     <div [@queryAnimation]=\"exp\">\n *       <h1>Title</h1>\n *       <div class=\"content\">\n *         Blah blah blah\n *       </div>\n *     </div>\n *   `,\n *   animations: [\n *    trigger('queryAnimation', [\n *      transition('* => goAnimate', [\n *        // hide the inner elements\n *        query('h1', style({ opacity: 0 })),\n *        query('.content', style({ opacity: 0 })),\n *\n *        // animate the inner elements in, one by one\n *        query('h1', animate(1000, style({ opacity: 1 })),\n *        query('.content', animate(1000, style({ opacity: 1 })),\n *      ])\n *    ])\n *  ]\n * })\n * class Cmp {\n *   exp = '';\n *\n *   goAnimate() {\n *     this.exp = 'goAnimate';\n *   }\n * }\n * ```\n *\n * @experimental Animation support is experimental.\n */\nexport function query(\n    selector: string, animation: AnimationMetadata | AnimationMetadata[],\n    options: AnimationQueryOptions | null = null): AnimationQueryMetadata {\n  return {type: AnimationMetadataType.Query, selector, animation, options};\n}\n\n/**\n * `stagger` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It is designed to be used inside of an animation {@link query query()}\n * and works by issuing a timing gap between after each queried item is animated.\n *\n * ### Usage\n *\n * In the example below there is a container element that wraps a list of items stamped out\n * by an ngFor. The container element contains an animation trigger that will later be set\n * to query for each of the inner items.\n *\n * ```html\n * <!-- list.component.html -->\n * <button (click)=\"toggle()\">Show / Hide Items</button>\n * <hr />\n * <div [@listAnimation]=\"items.length\">\n *   <div *ngFor=\"let item of items\">\n *     {{ item }}\n *   </div>\n * </div>\n * ```\n *\n * The component code for this looks as such:\n *\n * ```ts\n * import {trigger, transition, style, animate, query, stagger} from '@angular/animations';\n * @Component({\n *   templateUrl: 'list.component.html',\n *   animations: [\n *     trigger('listAnimation', [\n *        //...\n *     ])\n *   ]\n * })\n * class ListComponent {\n *   items = [];\n *\n *   showItems() {\n *     this.items = [0,1,2,3,4];\n *   }\n *\n *   hideItems() {\n *     this.items = [];\n *   }\n *\n *   toggle() {\n *     this.items.length ? this.hideItems() : this.showItems();\n *   }\n * }\n * ```\n *\n * And now for the animation trigger code:\n *\n * ```ts\n * trigger('listAnimation', [\n *   transition('* => *', [ // each time the binding value changes\n *     query(':leave', [\n *       stagger(100, [\n *         animate('0.5s', style({ opacity: 0 }))\n *       ])\n *     ]),\n *     query(':enter', [\n *       style({ opacity: 0 }),\n *       stagger(100, [\n *         animate('0.5s', style({ opacity: 1 }))\n *       ])\n *     ])\n *   ])\n * ])\n * ```\n *\n * Now each time the items are added/removed then either the opacity\n * fade-in animation will run or each removed item will be faded out.\n * When either of these animations occur then a stagger effect will be\n * applied after each item's animation is started.\n *\n * @experimental Animation support is experimental.\n */\nexport function stagger(\n    timings: string | number,\n    animation: AnimationMetadata | AnimationMetadata[]): AnimationStaggerMetadata {\n  return {type: AnimationMetadataType.Stagger, timings, animation};\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport function scheduleMicroTask(cb: () => any) {\n  Promise.resolve(null).then(cb);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {scheduleMicroTask} from '../util';\n\n/**\n * AnimationPlayer controls an animation sequence that was produced from a programmatic animation.\n * (see {@link AnimationBuilder AnimationBuilder} for more information on how to create programmatic\n * animations.)\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationPlayer {\n  onDone(fn: () => void): void;\n  onStart(fn: () => void): void;\n  onDestroy(fn: () => void): void;\n  init(): void;\n  hasStarted(): boolean;\n  play(): void;\n  pause(): void;\n  restart(): void;\n  finish(): void;\n  destroy(): void;\n  reset(): void;\n  setPosition(p: any /** TODO #9100 */): void;\n  getPosition(): number;\n  parentPlayer: AnimationPlayer|null;\n  readonly totalTime: number;\n  beforeDestroy?: () => any;\n  /* @internal */\n  triggerCallback?: (phaseName: string) => void;\n  /* @internal */\n  disabled?: boolean;\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class NoopAnimationPlayer implements AnimationPlayer {\n  private _onDoneFns: Function[] = [];\n  private _onStartFns: Function[] = [];\n  private _onDestroyFns: Function[] = [];\n  private _started = false;\n  private _destroyed = false;\n  private _finished = false;\n  public parentPlayer: AnimationPlayer|null = null;\n  public readonly totalTime: number;\n  constructor(duration: number = 0, delay: number = 0) { this.totalTime = duration + delay; }\n  private _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n  onStart(fn: () => void): void { this._onStartFns.push(fn); }\n  onDone(fn: () => void): void { this._onDoneFns.push(fn); }\n  onDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n  hasStarted(): boolean { return this._started; }\n  init(): void {}\n  play(): void {\n    if (!this.hasStarted()) {\n      this._onStart();\n      this.triggerMicrotask();\n    }\n    this._started = true;\n  }\n\n  /* @internal */\n  triggerMicrotask() { scheduleMicroTask(() => this._onFinish()); }\n\n  private _onStart() {\n    this._onStartFns.forEach(fn => fn());\n    this._onStartFns = [];\n  }\n\n  pause(): void {}\n  restart(): void {}\n  finish(): void { this._onFinish(); }\n  destroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      if (!this.hasStarted()) {\n        this._onStart();\n      }\n      this.finish();\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n  reset(): void {}\n  setPosition(p: number): void {}\n  getPosition(): number { return 0; }\n\n  /* @internal */\n  triggerCallback(phaseName: string): void {\n    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {scheduleMicroTask} from '../util';\nimport {AnimationPlayer} from './animation_player';\n\nexport class AnimationGroupPlayer implements AnimationPlayer {\n  private _onDoneFns: Function[] = [];\n  private _onStartFns: Function[] = [];\n  private _finished = false;\n  private _started = false;\n  private _destroyed = false;\n  private _onDestroyFns: Function[] = [];\n\n  public parentPlayer: AnimationPlayer|null = null;\n  public totalTime: number = 0;\n  public readonly players: AnimationPlayer[];\n\n  constructor(_players: AnimationPlayer[]) {\n    this.players = _players;\n    let doneCount = 0;\n    let destroyCount = 0;\n    let startCount = 0;\n    const total = this.players.length;\n\n    if (total == 0) {\n      scheduleMicroTask(() => this._onFinish());\n    } else {\n      this.players.forEach(player => {\n        player.onDone(() => {\n          if (++doneCount == total) {\n            this._onFinish();\n          }\n        });\n        player.onDestroy(() => {\n          if (++destroyCount == total) {\n            this._onDestroy();\n          }\n        });\n        player.onStart(() => {\n          if (++startCount == total) {\n            this._onStart();\n          }\n        });\n      });\n    }\n\n    this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);\n  }\n\n  private _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n\n  init(): void { this.players.forEach(player => player.init()); }\n\n  onStart(fn: () => void): void { this._onStartFns.push(fn); }\n\n  private _onStart() {\n    if (!this.hasStarted()) {\n      this._started = true;\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n    }\n  }\n\n  onDone(fn: () => void): void { this._onDoneFns.push(fn); }\n\n  onDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n\n  hasStarted() { return this._started; }\n\n  play() {\n    if (!this.parentPlayer) {\n      this.init();\n    }\n    this._onStart();\n    this.players.forEach(player => player.play());\n  }\n\n  pause(): void { this.players.forEach(player => player.pause()); }\n\n  restart(): void { this.players.forEach(player => player.restart()); }\n\n  finish(): void {\n    this._onFinish();\n    this.players.forEach(player => player.finish());\n  }\n\n  destroy(): void { this._onDestroy(); }\n\n  private _onDestroy() {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this._onFinish();\n      this.players.forEach(player => player.destroy());\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n\n  reset(): void {\n    this.players.forEach(player => player.reset());\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n\n  setPosition(p: number): void {\n    const timeAtPosition = p * this.totalTime;\n    this.players.forEach(player => {\n      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\n      player.setPosition(position);\n    });\n  }\n\n  getPosition(): number {\n    let min = 0;\n    this.players.forEach(player => {\n      const p = player.getPosition();\n      min = Math.min(p, min);\n    });\n    return min;\n  }\n\n  beforeDestroy(): void {\n    this.players.forEach(player => {\n      if (player.beforeDestroy) {\n        player.beforeDestroy();\n      }\n    });\n  }\n\n  /* @internal */\n  triggerCallback(phaseName: string): void {\n    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {AnimationGroupPlayer as ÉµAnimationGroupPlayer} from './players/animation_group_player';\nexport const ÉµPRE_STYLE = '!';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}