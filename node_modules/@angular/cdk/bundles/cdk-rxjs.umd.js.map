{"version":3,"file":"cdk-rxjs.umd.js","sources":["../../src/cdk/rxjs/index.ts","../../src/cdk/rxjs/rx-operators.ts","../../src/cdk/rxjs/rx-chain.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {RxChain,StrictRxChain,FinallyBrand,CatchBrand,DoBrand,MapBrand,FilterBrand,ShareBrand,FirstBrand,SwitchMapBrand,StartWithBrand,DebounceTimeBrand,AuditTimeBrand,TakeUntilBrand,finallyOperatorType,catchOperatorType,doOperatorType,mapOperatorType,filterOperatorType,shareOperatorType,firstOperatorType,switchMapOperatorType,startWithOperatorType,debounceTimeOperatorType,auditTimeOperatorType,takeUntilOperatorType,finallyOperator,catchOperator,doOperator,map,filter,share,first,switchMap,startWith,debounceTime,auditTime,takeUntil} from './public_api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable, ObservableInput} from 'rxjs/Observable';\nimport {PartialObserver} from 'rxjs/Observer';\nimport {Subscription} from 'rxjs/Subscription';\nimport {IScheduler} from 'rxjs/Scheduler';\nimport {_finally as _finallyOperator} from 'rxjs/operator/finally';\nimport {_catch as _catchOperator} from 'rxjs/operator/catch';\nimport {_do as _doOperator} from 'rxjs/operator/do';\nimport {map as mapOperator} from 'rxjs/operator/map';\nimport {filter as filterOperator} from 'rxjs/operator/filter';\nimport {share as shareOperator} from 'rxjs/operator/share';\nimport {first as firstOperator} from 'rxjs/operator/first';\nimport {switchMap as switchMapOperator} from 'rxjs/operator/switchMap';\nimport {startWith as startWithOperator} from 'rxjs/operator/startWith';\nimport {debounceTime as debounceTimeOperator} from 'rxjs/operator/debounceTime';\nimport {auditTime as auditTimeOperator} from 'rxjs/operator/auditTime';\nimport {takeUntil as takeUntilOperator} from 'rxjs/operator/takeUntil';\n\n/**\n * Represents a strongly-typed chain of RxJS operators.\n *\n * We achieve strict type enforcement on the chained operators by creating types that\n * *unambiguously* match specific rxjs operators. These unambiguous types are created by\n * intersecting a \"brand\" to the `typeof` the existing operator. The brand (a class with a private\n * member) effectively forces nominal typing for the operators. This allows typescript to understand\n * that, for example, `filter` is *`filter`* and not, say, a map of T => boolean.\n *\n * The downside to this approach is that operators must be imported in their type-coerced form\n * rather than from the normal rxjs location.\n */\nexport interface StrictRxChain<T> {\n  call<R>(operator: mapOperatorType<T, R>,\n      project: (value: T, index: number) => R, thisArg?: any): StrictRxChain<R>;\n\n  call<R>(operator: switchMapOperatorType<T, R>,\n      project: (value: T, index: number) => ObservableInput<R>): StrictRxChain<R>;\n\n  call<R>(operator: catchOperatorType<T, R>,\n      selector: (err: any, caught: Observable<T>) => ObservableInput<R>): StrictRxChain<T | R>;\n\n  call(operator: filterOperatorType<T>,\n      predicate: (value: T, index: number) => boolean, thisArg?: any): StrictRxChain<T>;\n\n  call(operator: shareOperatorType<T>): StrictRxChain<T>;\n\n  call(operator: finallyOperatorType<T>, action: () => void): StrictRxChain<T>;\n\n  call(operator: doOperatorType<T>, next: (x: T) => void, error?:\n      (e: any) => void, complete?: () => void): StrictRxChain<T>;\n\n  call(operator: doOperatorType<T>, observer: PartialObserver<T>): StrictRxChain<T>;\n\n  call(operator: firstOperatorType<T>, thisArg?: any, defaultValue?: any): StrictRxChain<T>;\n\n  call(operator: firstOperatorType<T>, predicate: (value: T) => boolean): StrictRxChain<T>;\n\n  call(operator: startWithOperatorType<T>, ...args: any[]): StrictRxChain<T>;\n\n  call(operator: debounceTimeOperatorType<T>, dueTime: number,\n      scheduler?: IScheduler): StrictRxChain<T>;\n\n  call(operator: auditTimeOperatorType<T>, duration: number,\n      scheduler?: IScheduler): StrictRxChain<T>;\n\n  call(operator: takeUntilOperatorType<T>, notifier: Observable<any>): StrictRxChain<T>;\n\n  subscribe(fn: (t: T) => void): Subscription;\n\n  result(): Observable<T>;\n}\nexport class FinallyBrand {\nprivate _; }\n\nfunction FinallyBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFinallyBrand.prototype._;\n}\n\nexport class CatchBrand {\nprivate _; }\n\nfunction CatchBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nCatchBrand.prototype._;\n}\n\nexport class DoBrand {\nprivate _; }\n\nfunction DoBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nDoBrand.prototype._;\n}\n\nexport class MapBrand {\nprivate _; }\n\nfunction MapBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nMapBrand.prototype._;\n}\n\nexport class FilterBrand {\nprivate _; }\n\nfunction FilterBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFilterBrand.prototype._;\n}\n\nexport class ShareBrand {\nprivate _; }\n\nfunction ShareBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nShareBrand.prototype._;\n}\n\nexport class FirstBrand {\nprivate _; }\n\nfunction FirstBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFirstBrand.prototype._;\n}\n\nexport class SwitchMapBrand {\nprivate _; }\n\nfunction SwitchMapBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nSwitchMapBrand.prototype._;\n}\n\nexport class StartWithBrand {\nprivate _; }\n\nfunction StartWithBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nStartWithBrand.prototype._;\n}\n\nexport class DebounceTimeBrand {\nprivate _; }\n\nfunction DebounceTimeBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nDebounceTimeBrand.prototype._;\n}\n\nexport class AuditTimeBrand {\nprivate _; }\n\nfunction AuditTimeBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nAuditTimeBrand.prototype._;\n}\n\nexport class TakeUntilBrand {\nprivate _; }\n\nfunction TakeUntilBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nTakeUntilBrand.prototype._;\n}\n\n\n\nexport type finallyOperatorType<T> = typeof _finallyOperator & FinallyBrand;\nexport type catchOperatorType<T, R> = typeof _catchOperator & CatchBrand;\nexport type doOperatorType<T> = typeof _doOperator & DoBrand;\nexport type mapOperatorType<T, R> = typeof mapOperator & MapBrand;\nexport type filterOperatorType<T> = typeof filterOperator & FilterBrand;\nexport type shareOperatorType<T> = typeof shareOperator & ShareBrand;\nexport type firstOperatorType<T> = typeof firstOperator & FirstBrand;\nexport type switchMapOperatorType<T, R> = typeof switchMapOperator & SwitchMapBrand;\nexport type startWithOperatorType<T> = typeof startWithOperator & StartWithBrand;\nexport type debounceTimeOperatorType<T> = typeof debounceTimeOperator & DebounceTimeBrand;\nexport type auditTimeOperatorType<T> = typeof auditTimeOperator & AuditTimeBrand;\nexport type takeUntilOperatorType<T> = typeof takeUntilOperator & TakeUntilBrand;\n\n// We add `Function` to the type intersection to make this nomically different from\n// `finallyOperatorType` while still being structurally the same. Without this, TypeScript tries to\n// reduce `typeof _finallyOperator & FinallyBrand` to `finallyOperatorType<T>` and then fails\n// because `T` isn't known.\nexport const /** @type {?} */ finallyOperator = /** @type {?} */((\n    _finallyOperator as typeof _finallyOperator & FinallyBrand & Function));\nexport const /** @type {?} */ catchOperator = /** @type {?} */(( _catchOperator as typeof _catchOperator & CatchBrand & Function));\nexport const /** @type {?} */ doOperator = /** @type {?} */(( _doOperator as typeof _doOperator & DoBrand & Function));\nexport const /** @type {?} */ map = /** @type {?} */(( mapOperator as typeof mapOperator & MapBrand & Function));\nexport const /** @type {?} */ filter = /** @type {?} */(( filterOperator as typeof filterOperator & FilterBrand & Function));\nexport const /** @type {?} */ share = /** @type {?} */(( shareOperator as typeof shareOperator & ShareBrand & Function));\nexport const /** @type {?} */ first = /** @type {?} */(( firstOperator as typeof firstOperator & FirstBrand & Function));\nexport const /** @type {?} */ switchMap = /** @type {?} */(( switchMapOperator as typeof switchMapOperator & SwitchMapBrand & Function));\nexport const /** @type {?} */ startWith = /** @type {?} */(( startWithOperator as typeof startWithOperator & StartWithBrand & Function));\nexport const /** @type {?} */ debounceTime = /** @type {?} */((\n    debounceTimeOperator as typeof debounceTimeOperator & DebounceTimeBrand & Function));\nexport const /** @type {?} */ auditTime = /** @type {?} */(( auditTimeOperator as typeof auditTimeOperator & AuditTimeBrand & Function));\nexport const /** @type {?} */ takeUntil = /** @type {?} */(( takeUntilOperator as typeof takeUntilOperator & TakeUntilBrand & Function));\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport {StrictRxChain} from './rx-operators';\n/**\n * Utility class used to chain RxJS operators.\n * \n * This class is the concrete implementation, but the type used by the user when chaining\n * is StrictRxChain. The strict chain enforces types on the operators to the same level as\n * the prototype-added equivalents.\n */\nexport class RxChain<T> {\n/**\n * @param {?} _context\n */\nprivate constructor(private _context: Observable<T>) { }\n/**\n * Starts a new chain and specifies the initial `this` value.\n * @template O\n * @param {?} context Initial `this` value for the chain.\n * @return {?}\n */\nstatic from<O>(context: Observable<O>): StrictRxChain<O> {\n    return new RxChain(context);\n  }\n/**\n * Invokes an RxJS operator as a part of the chain.\n * @param {?} operator Operator to be invoked.\n * @param {...?} args Arguments to be passed to the operator.\n * @return {?}\n */\ncall(operator: Function, ...args: any[]): RxChain<any> {\n    this._context = operator.call(this._context, ...args);\n    return this;\n  }\n/**\n * Subscribes to the result of the chain.\n * @param {?} fn Callback to be invoked when the result emits a value.\n * @return {?}\n */\nsubscribe(fn: (t: T) => void): Subscription {\n    return this._context.subscribe(fn);\n  }\n/**\n * Returns the result of the chain.\n * @return {?}\n */\nresult(): Observable<T> {\n    return this._context;\n  }\n}\n\nfunction RxChain_tsickle_Closure_declarations() {\n/** @type {?} */\nRxChain.prototype._context;\n}\n\n"],"names":["startWithOperator","_catchOperator"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;QEuBA,IAAA,CAAA,QAAA,GAHqD,QAGrD,CAAA;KAHA;;;;;;;;QAUA,OAJG,IAIH,OAAA,CAAA,OAAA,CAAA,CAAA;KACA,CAAA;;;;;;;;QAIG,IAIH,IAAA,GAJG,EAIH,CAJG;QAKC,KAJK,IAIT,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAAA;YACA,IAAA,CAAA,EAJW,GAIX,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA,CAAA;SACA;;;;;;;;;;;;;;;;IAgBA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;;KDoBA,CAAA;IACA,OAAA,OAAA,CAAA;CAEA,EAAA,CAAA,CAAA;AADA,IAAA,YAAA,IAAA,YAAA;IASA,SAKA,YALA,GAAA;KARA;IAgBA,OAAA,YAAA,CAAA;CAfmC,EAAnC,CAAA,CAAA;AAuBA,IAAA,UAAA,IAKA,YALA;IAtBA,SAAA,UAAA,GAAA;KA8BA;IA7BA,OAAA,UAAA,CAAA;CAqCA,EAAA,CAAA,CAAA;AApCA,IAAA,OAAA,IAAA,YAAA;IA4CA,SAAA,OAKA,GALA;KA3CA;IAmDA,OAAA,OAAA,CAAA;CAlDyC,EAAzC,CAAA,CAAA;AA0DA,IAAA,QAAA,IAAA,YAAA;IAzDA,SAAA,QAAA,GAAA;KAiEA;IAhEA,OAAA,QAAA,CAAA;CAwEA,EAAA,CAAA,CAAA;AAvEA,IAAA,WAAA,IAAA,YAAA;IA+EA,SAAA,WAAA,GAAA;;;;AAwBA,IAAA,UAAA,IAAA,YAAA;IAEA,SAAA,UAnF6BC,GAmF7B;KACA;IACA,OAnFa,UAmFb,CAAA;CACA,EAAA,CAAA,CAAA;AACA,IAAA,UAAA,IAAA,YAAA;IACA,SAnFa,UAA6D,GAmF1E;KACA;IACA,OAAA,UAnFyBD,CAmFzB;CACA,EAAA,CAAA,CAAA;AAEA,IAAA,cAAA,IAAA,YAAA;IACA,SAAA,cAAA,GAnF0F;;ID3H1F,OAAA,cAAA,CAAA;;AAEA,IAAA,cAAA,IAAA,YAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}