{"version":3,"sources":["../../../../src/lib/media-query/observable-media.ts"],"names":[],"mappings":"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","file":"observable-media.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injectable} from '@angular/core';\n\nimport {Subscription} from 'rxjs/Subscription';\nimport {Observable, Subscribable} from \"rxjs/Observable\";\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/filter';\n\nimport {BreakPointRegistry} from './breakpoints/break-point-registry';\n\nimport {MediaChange} from './media-change';\nimport {MatchMedia} from './match-media';\nimport {mergeAlias} from './../utils/add-alias';\nimport {BreakPoint} from './breakpoints/break-point';\n\n/**\n * Base class for MediaService and pseudo-token for\n */\nexport abstract class ObservableMedia implements Subscribable<MediaChange> {\n  abstract isActive(query: string): boolean;\n\n  abstract asObservable(): Observable<MediaChange>;\n\n  abstract subscribe(next?: (value: MediaChange) => void,\n                     error?: (error: any) => void,\n                     complete?: () => void): Subscription;\n}\n\n/**\n * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.\n\n * This an Observable with that exposes a feature to subscribe to mediaQuery\n * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is\n * currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional\n * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use\n * `.asObservable()` with syntax like media.asObservable().map(....).\n *\n *  @usage\n *\n *  // RxJS\n *  import 'rxjs/add/operator/filter';\n *  import { ObservableMedia } from '@angular/flex-layout';\n *\n *  @Component({ ... })\n *  export class AppComponent {\n *    status : string = '';\n *\n *    constructor(  media:ObservableMedia ) {\n *      let onChange = (change:MediaChange) => {\n *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : \"\";\n *      };\n *\n *      // Subscribe directly or access observable to use filter/map operators\n *      // e.g.\n *      //      media.subscribe(onChange);\n *\n *      media.asObservable()\n *        .filter((change:MediaChange) => true)   // silly noop filter\n *        .subscribe(onChange);\n *    }\n *  }\n */\n\nexport class MediaService implements ObservableMedia {\n  /**\n   * Should we announce gt-<xxx> breakpoint activations ?\n   */\n  public filterOverlaps = true;\n\n  constructor(private mediaWatcher: MatchMedia,\n              private breakpoints: BreakPointRegistry) {\n    this.observable$ = this._buildObservable();\n    this._registerBreakPoints();\n  }\n\n  /**\n   * Test if specified query/alias is active.\n   */\n  isActive(alias): boolean {\n    let query = this._toMediaQuery(alias);\n    return this.mediaWatcher.isActive(query);\n  };\n\n  /**\n   * Proxy to the Observable subscribe method\n   */\n  subscribe(next?: (value: MediaChange) => void,\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n    return this.observable$.subscribe(next, error, complete);\n  };\n\n  /**\n   * Access to observable for use with operators like\n   * .filter(), .map(), etc.\n   */\n  asObservable(): Observable<MediaChange> {\n    return this.observable$;\n  }\n\n  // ************************************************\n  // Internal Methods\n  // ************************************************\n\n  /**\n   * Register all the mediaQueries registered in the BreakPointRegistry\n   * This is needed so subscribers can be auto-notified of all standard, registered\n   * mediaQuery activations\n   */\n  private _registerBreakPoints() {\n    this.breakpoints.items.forEach((bp: BreakPoint) => {\n      this.mediaWatcher.registerQuery(bp.mediaQuery);\n      return bp;\n    });\n  }\n\n  /**\n   * Prepare internal observable\n   * NOTE: the raw MediaChange events [from MatchMedia] do not contain important alias information\n   * these must be injected into the MediaChange\n   */\n  private _buildObservable() {\n    const self = this;\n    // Only pass/announce activations (not de-activations)\n    // Inject associated (if any) alias information into the MediaChange event\n    // Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n    const activationsOnly = (change: MediaChange) => {\n      return change.matches === true;\n    };\n    const addAliasInformation = (change: MediaChange) => {\n      return mergeAlias(change, this._findByQuery(change.mediaQuery));\n    };\n    const excludeOverlaps = (change: MediaChange) => {\n      let bp = this.breakpoints.findByQuery(change.mediaQuery);\n      return !bp ? true : !(self.filterOverlaps && bp.overlapping);\n    };\n\n    return this.mediaWatcher.observe()\n        .filter(activationsOnly)\n        .map(addAliasInformation)\n        .filter(excludeOverlaps);\n  }\n\n  /**\n   * Breakpoint locator by alias\n   */\n  private _findByAlias(alias) {\n    return this.breakpoints.findByAlias(alias);\n  }\n\n  /**\n   * Breakpoint locator by mediaQuery\n   */\n  private _findByQuery(query) {\n    return this.breakpoints.findByQuery(query);\n  };\n\n  /**\n   * Find associated breakpoint (if any)\n   */\n  private _toMediaQuery(query) {\n    let bp: BreakPoint = this._findByAlias(query) || this._findByQuery(query);\n    return bp ? bp.mediaQuery : query;\n  };\n\n  private observable$: Observable<MediaChange>;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: MatchMedia, },\n{type: BreakPointRegistry, },\n];\n}\n\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}